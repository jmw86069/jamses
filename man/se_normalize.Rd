% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jam_senormalize.R
\name{se_normalize}
\alias{se_normalize}
\title{Normalize SummarizedExperiment data}
\usage{
se_normalize(
  se,
  method = c("quantile", "jammanorm", "limma_batch_adjust", "TMM", "TMMwsp", "RLE"),
  assay_names = NULL,
  output_method_prefix = NULL,
  output_assay_names = NULL,
  genes = NULL,
  samples = NULL,
  params = list(quantile = list(ties = TRUE), jammanorm = list(controlGenes = NULL,
    minimum_mean = 0, controlSamples = NULL, centerGroups = NULL, useMedian = FALSE,
    noise_floor = NULL, noise_floor_value = NULL), limma_batch_adjust = list(batch =
    NULL, group = NULL), TMM = list(refColumn = NULL, logratioTrim = 0.3, sumTrim = 0.05,
    doWeighting = TRUE, Acutoff = NULL), TMMwsp = list(refColumn = NULL, logratioTrim =
    0.3, sumTrim = 0.05, doWeighting = TRUE, Acutoff = NULL), RLE = list(refColumn =
    NULL, logratioTrim = 0.3, 
     sumTrim = 0.05, doWeighting = TRUE, Acutoff = NULL)),
  normgroup = NULL,
  floor = 0,
  enforce_norm_floor = TRUE,
  output_sep = "_",
  override = TRUE,
  populate_mcols = TRUE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{se}{\code{SummarizedExperiment} object}

\item{method}{\code{character} vector indicating which normalization method(s)
to apply.
\itemize{
\item \code{"quantile"}: quantile normalization via \code{limma::normalizeQuantiles()}
\item \code{"jammanorm"}: log-ratio normalization via \code{jamma::jammanorm()}
\item \code{"limma_batch_adjust"}: batch adjustment via
\code{limma::removeBatchEffect()}, recommended for data visualization,
but not recommended for downstream statistical comparisons.
\item \code{"TMM"}: trimmed mean of M-values via \code{edgeR::calcNormFactors()}
\item \code{"TMMwsp"}: TMM with singleton pairing via \code{edgeR::calcNormFactors()}
\item \code{"RLE"}: relative log expression via \code{edgeR::calcNormFactors()}
}}

\item{assay_names}{\code{character} vector or one or more \code{names(assays(se))}
that indicates which numeric matrix to use during normalization. When
multiple values are provided, each matrix is normalized independently
by each \code{method}.}

\item{output_method_prefix}{\code{character} vector (optional) with custom
method prefix values to use when creating the new \code{assay_name} for
each normalization. It must have length equal to \code{length(method)},
to be applied to each method in order.
Note that \code{output_assay_names} takes priority, and when it is defined
the \code{output_method_prefix} entries are ignored.

Consider these arguments:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{assay_name="counts",
method="limma_batch_adjust",
output_method_prefix="lba"
}\if{html}{\out{</div>}}

The assay_name created during normalization will be \code{"lba_counts"}.}

\item{output_assay_names}{\code{character} vector (optional) which overrides
the default method for defining assay names for normalized data.
This vector length must equal \code{length(method) * length(assay_names)},
and will be applied in the order data is normalized:
\enumerate{
\item \code{assay_names} are iterated.
\item For each value in \code{assay_names}, each normalization in \code{method}
is applied.
}

Therefore the order of \code{output_assay_names} could follow this order:
\code{method1_assay1}, \code{method1_assay2}, \code{method2_assay1}, \code{method2_assay2}.}

\item{genes}{\code{character} vector (optional) used to define a subset of
gene rows in \code{se} to use for normalization.
Values must match \code{rownames(se)}.}

\item{samples}{\code{character} vector (optional) used to define a subset of
sample columns in \code{se} to use for normalization.
Values must match \code{colnames(se)}.}

\item{params}{\code{list} (optional) parameters specific to each
normalization method, passed to \code{matrix_normalize()}. Any
value which is not defined in the \code{params} provided will use
the default value in \code{matrix_normalize()}, for example
\code{params=list(jammanorm=list(minimum_mean=2))} will use
\code{minimum_mean=2} then use other default values relevant
to the \code{jammanorm} normalization method.}

\item{normgroup}{\code{character} or equivalent vector that defines subgroups
of \code{samples} to be normalized indendently of each normgroup. When
\code{NULL} then all data is normalized together as default.
The \code{normgroup} vector is expected to be in the same order as
\code{samples}, or \code{names(normgroup)} must contain all \code{samples}.}

\item{output_sep}{\code{character} string used as a delimited between the
\code{method} and the \code{assay_names} to define the output assay name,
for example when \code{assay_name="counts"}, \code{method="quantile"},
and \code{output_sep="_"} the new assay name will be \code{"quantile_counts"}.}

\item{override}{\code{logical} indicating whether to override any pre-existing
matrix values with the same output assay name. When \code{override=FALSE}
and the output assay name already exists, the normalization will
not be performed.}

\item{populate_mcols}{\code{logical} indicating whether to populate
normalization details into \code{mcols(assays(se))}, including
the normalization \code{method},
the source \code{assay_name} used during normalization, and
values from \code{params}.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{...}{additional arguments are passed to \code{matrix_normalize()}.}
}
\value{
\code{SummarizedExperiment} object where the normalized output
is added to \code{assays(se)} using the naming format \code{method_assayname}.
}
\description{
Normalize SummarizedExperiment data
}
\details{
This function applies one or more data normalization methods
to an input \code{SummarizedExperiment} object. The normalization is
applied to one or more matrix data stored in \code{assays(se)},
each one is run independently.

Note that supplying \code{genes} and \code{samples} will apply normalization
to only those \code{genes} and \code{samples}, and this data will be
stored in the full \code{SummarizedExperiment} object \code{se} with
\code{NA} values used to fill any values not present in \code{genes}
or \code{samples}.

For example if \code{assay_names} contains two assay names,
and \code{method} contains two methods, the output will include
four normalizations, where each assay name is normalized two ways.
The output assay names will be something like \code{"assay1_method1"},
\code{"assay1_method2"}, \code{"assay2_method1"}, \code{"assay2_method2"}.
It is not always necessary to normalize data by multiple different
methods, however when two methods are similar and need to be
compared, the \code{SummarizedExperiment} object is a convenient
place to store different normalization results for downstream
comparison. Further, the method \code{se_contrast_stats()} is able
to apply equivalent statistical contrasts to each normalization,
and returns an array of statistical hits which is convenient
for direct comparison of results.

This method calls \code{matrix_normalize()} to perform each normalization
step, see that function description for details on each method.
}
\examples{
if (jamba::check_pkg_installed("farrisdata")) {

   # se_normalize
   # suppressPackageStartupMessages(library(SummarizedExperiment))
   GeneSE <- farrisdata::farrisGeneSE;
   samples <- colnames(GeneSE);
   genes <- rownames(GeneSE);

   GeneSE <- se_normalize(GeneSE,
      genes=genes,
      samples=samples,
      assay_names=c("raw_counts", "counts"),
      method="jammanorm",
      params=list(jammanorm=list(minimum_mean=5)))
   SummarizedExperiment::mcols(SummarizedExperiment::assays(GeneSE))
   names(SummarizedExperiment::assays(GeneSE))

   # review normalization factor values
   round(digits=3, attr(
      SummarizedExperiment::assays(GeneSE)$jammanorm_raw_counts, "nf"))

   # the data in "counts" was already normalized
   # so the normalization factors are very near 0 as expected
   round(digits=3,
      attr(SummarizedExperiment::assays(GeneSE)$jammanorm_counts, "nf"))


   # note that housekeeper genes are supplied in params
   # also this demonstrates output_method_prefix
   set.seed(123);
   hkgenes <- sample(rownames(GeneSE), 1000)
   GeneSE <- se_normalize(GeneSE,
      genes=genes,
      samples=samples,
      assay_names=c("raw_counts"),
      method="jammanorm",
      output_method_prefix="hkjammanorm",
      params=list(jammanorm=list(minimum_mean=5,
         controlGenes=hkgenes)))
   SummarizedExperiment::mcols(SummarizedExperiment::assays(GeneSE))

   # example showing quantile normalization
   GeneSE <- se_normalize(GeneSE,
      assay_names=c("raw_counts"),
      method="quantile")
   SummarizedExperiment::mcols(SummarizedExperiment::assays(GeneSE))

   # example showing quantile normalization with custom output_assay_names
   GeneSE <- se_normalize(GeneSE,
      assay_names=c("raw_counts"),
      method="quantile",
      output_assay_names="newquantile_raw_counts")
   SummarizedExperiment::mcols(SummarizedExperiment::assays(GeneSE))
}


}
\seealso{
Other jamses stats: 
\code{\link{ebayes2dfs}()},
\code{\link{handle_na_values}()},
\code{\link{matrix_normalize}()},
\code{\link{run_limma_replicate}()},
\code{\link{se_contrast_stats}()},
\code{\link{voom_jam}()}
}
\concept{jamses stats}
