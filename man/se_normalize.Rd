% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jam_senormalize.R
\name{se_normalize}
\alias{se_normalize}
\title{Normalize SummarizedExperiment data}
\usage{
se_normalize(
  se,
  method = c("quantile", "jammanorm", "limma_batch_adjust"),
  assay_names = NULL,
  genes = NULL,
  samples = NULL,
  params = list(quantile = list(ties = TRUE), jammanorm = list(controlGenes = NULL,
    minimum_mean = 0, controlSamples = NULL, centerGroups = NULL, useMedian = FALSE,
    noise_floor = NULL, noise_floor_value = NULL), limma_batch_adjust = list(batch =
    NULL, group = NULL)),
  output_sep = "_",
  override = TRUE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{se}{\code{SummarizedExperiment} object}

\item{method}{\code{character} vector indicating which normalization method(s)
to apply.}

\item{assay_names}{\code{character} vector or one or more \code{names(assays(se))}
that indicates which numeric matrix to use during normalization. When
multiple values are provided, each matrix is normalized independently
by each \code{method}.}

\item{genes}{\code{character} vector (optional) used to define a subset of
gene rows in \code{se} to use for normalization.
Values must match \code{rownames(se)}.}

\item{samples}{\verb{character vector (optional) used to define a subset of sample columns in }se\verb{to use for normalization. Values must match}colnames(se)`.}

\item{params}{\code{list} (optional) parameters specific to each
normalization method, passed to \code{matrix_normalize()}. Any
value which is not defined in the \code{params} provided will use
the default value in \code{matrix_normalize()}, for example
\code{params=list(jammanorm=list(minimum_mean=2))} will use
\code{minimum_mean=2} then use other default values relevant
to the \code{jammanorm} normalization method.}

\item{output_sep}{\code{character} string used as a delimited between the
\code{method} and the \code{assay_names} to define the output assay name,
for example when \code{assay_name="counts"}, \code{method="quantile"},
and \code{output_sep="_"} the new assay name will be \code{"quantile_counts"}.}

\item{override}{\code{logical} indicating whether to override any pre-existing
matrix values with the same output assay name. When \code{override=FALSE}
and the output assay name already exists, the normalization will
not be performed.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{...}{additional arguments are passed to \code{matrix_normalize()}.}
}
\value{
\code{SummarizedExperiment} object where the normalized output
is added to \code{assays(se)} using the naming format \code{method_assayname}.
}
\description{
Normalize SummarizedExperiment data
}
\details{
This function applies one or more data normalization methods
to an input \code{SummarizedExperiment} object. The normalization is
applied to one or more matrix data stored in \code{assays(se)},
each one is run independently.

Note that supplying \code{genes} and \code{samples} will apply normalization
to only those \code{genes} and \code{samples}, and this data will be
stored in the full \code{SummarizedExperiment} object \code{se} with
\code{NA} values used to fill any values not present in \code{genes}
or \code{samples}.

For example if \code{assay_names} contains two assay names,
and \code{method} contains two methods, the output will include
four normalizations, where each assay name is normalized two ways.
The output assay names will be something like \code{"assay1_method1"},
\code{"assay1_method2"}, \code{"assay2_method1"}, \code{"assay2_method2"}.
It is not always necessary to normalize data by multiple different
methods, however when two methods are similar and need to be
compared, the \code{SummarizedExperiment} object is a convenient
place to store different normalization results for downstream
comparison. Further, the method \code{se_contrast_stats()} is able
to apply equivalent statistical contrasts to each normalization,
and returns an array of statistical hits which is convenient
for direct comparison of results.

This method calls \code{matrix_normalize()} to perform each normalization
step, see that function description for details on each method.
}
\examples{
if (jamba::check_pkg_installed("farrisdata")) {

   # se_normalize
   suppressPackageStartupMessages(library(SummarizedExperiment))
   GeneSE <- farrisdata::farrisGeneSE;
   samples <- colnames(GeneSE);
   genes <- rownames(GeneSE);

   GeneSE <- se_normalize(GeneSE,
      genes=genes,
      samples=samples,
      assay_names=c("raw_counts", "counts"),
      method="jammanorm",
      params=list(jammanorm=list(minimum_mean=5)))
   names(assays(GeneSE))

   # review normalization factor values
   round(digits=3, attr(assays(GeneSE)$jammanorm_raw_counts, "nf"))

   # the data in "counts" was already normalized
   # so the normalization factors are very near 0 as expected
   round(digits=3, attr(assays(GeneSE)$jammanorm_counts, "nf"))


   # note that housekeeper genes are supplied in params
   set.seed(123);
   hkgenes <- sample(rownames(GeneSE), 1000)
   GeneSE <- se_normalize(GeneSE,
      genes=genes,
      samples=samples,
      assay_names=c("raw_counts"),
      method="jammanorm",
      params=list(jammanorm=list(minimum_mean=5,
         controlGenes=hkgenes)))
   round(digits=3, attr(assays(GeneSE)$jammanorm_raw_counts, "nf"))

   # example showing quantile normalization
   GeneSE <- se_normalize(GeneSE,
      assay_names=c("raw_counts"),
      method="quantile",
      params=list(jammanorm=list(min_mean=5)))
}


}
\seealso{
Other jamses stats: 
\code{\link{ebayes2dfs}()},
\code{\link{handle_na_values}()},
\code{\link{matrix_normalize}()},
\code{\link{run_limma_replicate}()},
\code{\link{se_contrast_stats}()},
\code{\link{voom_jam}()}
}
\concept{jamses stats}
