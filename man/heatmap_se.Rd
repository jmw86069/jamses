% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jam_sestats_hm.R
\name{heatmap_se}
\alias{heatmap_se}
\title{Expression heatmap of sestats hits}
\usage{
heatmap_se(
  se,
  sestats = NULL,
  rows = NULL,
  row_type = "rows",
  data_type = "expression",
  correlation = FALSE,
  assay_name = NULL,
  contrast_names = NULL,
  contrast_suffix = "",
  cutoff_name = NULL,
  alt_sestats = NULL,
  alt_assay_name = assay_name,
  alt_contrast_names = NULL,
  alt_contrast_suffix = "",
  alt_cutoff_name = NULL,
  isamples = colnames(se),
  normgroup_colname = NULL,
  centerby_colnames = NULL,
  controlSamples = NULL,
  control_label = "",
  controlFloor = NA,
  naControlAction = c("na", "row", "floor", "min"),
  naControlFloor = 0,
  top_colnames = NULL,
  top_annotation = NULL,
  top_annotation_name_gp = grid::gpar(),
  rowData_colnames = NULL,
  left_annotation = NULL,
  left_annotation_name_gp = grid::gpar(),
  left_annotation_name_rot = 90,
  right_annotation = NULL,
  simple_anno_size = grid::unit(8, "mm"),
  legend_title_gp = grid::gpar(fontsize = 10),
  legend_labels_gp = grid::gpar(fontsize = 10),
  legend_grid_cex = 1,
  row_names_gp = NULL,
  row_split = NULL,
  row_subcluster = NULL,
  row_title_rot = 0,
  sample_color_list = NULL,
  legend_at = NULL,
  legend_labels = NULL,
  subset_legend_colors = TRUE,
  row_cex = 0.8,
  column_cex = 1,
  row_anno_fontsize = 11,
  useMedian = FALSE,
  show_row_names = NULL,
  show_row_dend = length(rows) < 2000,
  mark_rows = NULL,
  mark_labels_gp = grid::gpar(),
  show_heatmap_legend = TRUE,
  show_top_legend = TRUE,
  show_left_legend = TRUE,
  show_top_annotation_name = TRUE,
  show_left_annotation_name = TRUE,
  row_label_colname = NULL,
  cluster_columns = FALSE,
  cluster_column_slices = FALSE,
  cluster_rows = function(x, ...) {     amap::hcluster(jamba::rmNA(naValue = 0, x),
    ..., method = "euclidean", link = "ward") },
  cluster_row_slices = FALSE,
  column_names_gp = NULL,
  column_split = NULL,
  column_split_sep = ",",
  color_max = 3,
  color_floor = 0,
  lens = 2,
  rename_contrasts = TRUE,
  rename_alt_contrasts = TRUE,
  use_raster = TRUE,
  verbose = FALSE,
  debug = FALSE,
  ...
)
}
\arguments{
\item{se}{\code{SummarizedExperiment} object with accessor functions:
\code{rowData()}, \code{colData()}, and \code{assays()};
or another suitable Bioconductor object with accessor functions:
\code{featureData()}, \code{phenoData()}, and \code{assayData()}.}

\item{sestats}{one of the following types of data:
\itemize{
\item \code{list} output from \code{se_contrast_stats()}, which
specifically contains \code{hit_array} as a 3-dimensional array of hits
with dimensions "Cutoffs", "Contrasts", "Signal".
\item \code{numeric} matrix intended to represent an incidence matrix,
where a value \code{0} indicates absence, and non-zero indicates presence.
This format is useful for supplying any incidence matrix, such as
gene-by-pathway (for example Github package "jmw86069/multienrichjam"
provides \code{mem$memIM} with gene-by-pathway matrix),
or gene-by-class (see Github package "jmw86069/pajam"
for examples using ProteinAtlas protein classification, including
membrane-bound, secreted, transcription factors, etc.), or any
incidence matrix defined by Github "jmw86069/venndir" function
\code{list2im_value()} or \code{list2im()} which converts input to a Venn diagram
into an incidence matrix.
\item When \code{sestats} is supplied, data is converted to incidence matrix,
then columns are matched with \code{contrast_names}. All rows with non-zero
entry in those columns are included in the heatmap.
When \code{rows} is also supplied, then the intersection of incidence
matrix rows and \code{rows} is displayed in the heatmap.
\item Note that \code{alt_sestats} does not subset rows displayed in the
heatmap.
}}

\item{rows}{\code{character} vector of \code{rownames(se)} to define a specific
set of rows to display. When \code{sestats} is supplied, then the
intersection of \code{rows} with genes defined by \code{sestats} is displayed.
Note that rows are required to be in \code{rownames(se)}, all other rows
are dropped.}

\item{row_type}{\code{character} string used in the title of the heatmap
which indicates how many rows are displayed. For example
\code{"1,234 genes detected above background"} or
\code{"1,234 DEGs by limma-voom"}.}

\item{data_type}{\code{character} string used as title of the heatmap
color gradient legend, for example \code{"expression"} indicates
the data contains gene expression measurements. Notes:
\itemize{
\item The prefix \code{"centered"} is automatically appended whenever
the data is also centered for the heatmap. Set \code{centerby_colnames=FALSE}
to display data that is not centered.
\item The prefix \code{"correlation of"} is automatically appended when
\code{correlation=TRUE} which displays correlation of whatever data
is included in the heatmap.
}}

\item{correlation}{\code{logical} indicating whether to calculate sample
correlation, and plot a sample-by-sample correlation heatmap.
This option is included here since many of the same arguments
are required for data centering, and sample annotations.
Note that \code{color_max} is forced to a maximum value of \code{1.0},
representing the maximum correlation value.}

\item{assay_name}{\code{character} string indicating the name in
\code{assays(se)} to use for data to be displayed in the heatmap.
\itemize{
\item When multiple \code{assay_name} values are supplied, the first
assay_name that matches \code{names(assays(se))} will be used in the
heatmap. In this way, multiple \code{assay_names} can be supplied to
define statistical hits in \code{sestats}, which calls \code{hit_array_to_list()}
to combine hits across \code{assay_name} entries; but only the first
\code{assay_name} found in \code{se} is used for the heatmap values.
\item When there is only one value for \code{assayNames(se)}, then
\code{assay_name} will default to this value, instead of acting like
it couldn't possibly know what was intended. Haha.
\item Lastly, \code{assay_name} can be a \code{numeric} index, helpful in case
\code{assays(se)} contains no names - not recommended but it can happen.
}}

\item{contrast_names}{\code{character} vector of contrasts in
\code{sestats$hit_array} to use for the heatmap. When \code{contrast_names=NULL}
then all contrasts are displayed, which is the default.}

\item{contrast_suffix}{\code{character} string with optional suffix to append
to the end of each contrast name label for \code{sestats} hit incidence
matrix beside the heatmap. This suffix may be useful when comparing
two methods for the same set of contrast names, with \code{sestats} and
\code{alt_sestats}.}

\item{cutoff_name}{\code{character} or \code{integer} index used to define the
specific statistical cutoffs to use from \code{sestats$hit_array}. This
argument is passed to \code{hit_array_to_list()} as \code{cutoff_names}.}

\item{alt_sestats, alt_assay_name, alt_contrast_names, alt_contrast_suffix}{arguments analogous to those described above for \code{sestats} which
are used when \code{alt_sestats} is supplied.}

\item{isamples}{\code{character} vector of \code{colnames(se)} used to visualize a
subset of samples used for the data centering step. Note that
data centering uses all columns supplied in \code{se}, and after centering,
the subset of columns defined in \code{isamples} is displayed in the heatmap.
This distinction makes it possible to center data by some control group,
then optionally not display the control group data.}

\item{normgroup_colname}{\code{character} vector of colnames in \code{colData(se)}
used during data centering. When supplied, samples are centered
independently within each normgroup grouping. These values are
equivalent to using \code{centerby_colnames}.}

\item{centerby_colnames}{either:
\itemize{
\item \code{character} vector of colnames in \code{colData(se)}
used during data centering. When supplied, samples are centered
independently within each centerby grouping. It is typically used
for things like cell lines, to center each cell line by a time
point control, or untreated control.
\item \code{NULL} to perform centering across all columns in \code{se}.
\item \code{FALSE} to disable centering.
}}

\item{controlSamples}{\code{character} optional vector of samples to use as the
reference during data centering. Note that samples are still
centered within each normgroup and centerby grouping, and within
that grouping samples are centered to the \code{controlSamples}
which are present in that grouping. Any center group for which no
samples are defined in \code{controlSamples} will use all samples in that
center group. Typically, \code{controlSamples} is used to define a
specific group as the reference for centering, so changes are displayed
relative to that group. Make sure to define \code{control_name} to include
an appropriate label in the heatmap title.}

\item{control_label}{\code{character} string used in heatmap title
to describe the control used during data centering, relevant when
\code{controlSamples} is also supplied.}

\item{controlFloor, naControlAction, naControlFloor}{passed to
\code{jamma::centerGeneData()} to customize data centering.
\itemize{
\item \code{controlFloor} imposes an optional noise floor to control group
mean/median values, so the summary value during centering is at
least \code{controlFloor}. Useful for defining an effective noise floor
for a platform technology.
\item \code{naControlAction} defines the action taken only when values for
all control samples are \code{NA}.
\item \code{naControlFloor} is a \code{numeric} value used when
\code{naControlAction="floor"}, which causes the group reference value
to use the value provided in \code{naControlFloor}.
}}

\item{top_colnames}{one of the following types:
\itemize{
\item \code{character} vector of colnames to use from
\code{colData(se)} as annotations to display in \code{top_annotation} above
the heatmap.
\item \code{NULL}, will call \code{choose_annotation_colnames()} to detect
reasonable colnames: columns with more than one unique value;
columns with at least one duplicated value.
\item \code{FALSE} will hide the \code{top_colnames}, which also occurs when
\code{colData(se)} is empty.
}}

\item{top_annotation}{specific heatmap annotation as defined by
\code{ComplexHeatmap::HeatmapAnnotation()}. When supplied, the \code{top_colnames}
described above is not used.}

\item{top_annotation_name_gp}{\code{grid::gpar} object to customize the
annotation name displayed beside the top annotation.}

\item{rowData_colnames}{\code{character} vector of colnames in \code{rowData(se)}
to use for heatmap annotations displayed on the left side of
the heatmap. Specific colors can be included in \code{sample_color_list}
as a named \code{list} of color vectors or color functions. The names
of this list must match colnames to be displayed, otherwise
\code{ComplexHeatmap::Heatmap()} will define its own color function.}

\item{left_annotation}{specific heatmap annotation as defined by
\code{ComplexHeatmap::rowAnnotation()}. When supplied, the \code{rowData_colnames}
and \code{sestats} row annotations are not displayed. In order to supply
custom row annotations and not lose \code{left_annotation} defined above,
supply the row annotations as \code{right_annotation}.}

\item{left_annotation_name_gp}{\code{grid::gpar} object to customize the
annotation name displayed beside the left annotation.}

\item{left_annotation_name_rot}{\code{numeric} rotation of left annotation
label, in degrees, where \code{0} indicates normal text, and \code{90} is
rotated vertically.}

\item{right_annotation}{specific heatmap annotation as defined by
\code{ComplexHeatmap::HeatmapAnnotation()}. This element is created
automatically when \code{mark_rows} is supplied.}

\item{simple_anno_size}{\code{grid::unit} size used to define heatmap
annotation sizes (height or width of each line) for any simple
annotations.}

\item{legend_title_gp}{\code{grid::gpar} to customize the legend title
fonts, applied to each legend: top annotation, left annotation,
main heatmap.}

\item{legend_labels_gp}{\code{grid::gpar} to customize the legend label
fonts, applied to each legend: top annotation, left annotation,
main heatmap.}

\item{legend_grid_cex}{\code{numeric} multiplied to adjust the relative
size of each legend grid unit, applied to each relevant metric.}

\item{row_names_gp}{\code{gpar} to define custom column name settings.
When \code{"fontsize"} is not defined, the automatic font size calculation
is added to the \code{row_names_gp} supplied.}

\item{row_split}{is used to define heatmap split by row, ultimately
passed to \code{ComplexHeatmap::Heatmap()} argument \code{row_split}. However,
the input type can vary:
\itemize{
\item \code{integer} number of row splits based upon row clustering
\item \code{character} value or values in colnames of \code{rowData(se)} to split
using row annotation in \code{se}.
\item \code{character} or \code{factor} vector named by \code{rownames(se)} with another
custom row split, passed directly to \code{ComplexHeatmap::Heatmap()}
argument \code{row_split}, with proper order for rows being displayed
}}

\item{row_subcluster}{\code{integer} or \code{character} vector representing one
or more elements returned by \code{row_split} to use as a drill-down
sub-cluster heatmap. This argument is experimental, and is intended
to make it easy to "drill down" into specific row clusters.
\itemize{
\item The process internally creates a full heatmap using all arguments
as defined, then extracts the \code{jamba::heatmap_row_order()} which
contains row split data in a \code{list} of rownames vectors. The \code{list}
elements that match \code{row_subcluster} are extracted and used again
for a subsequent heatmap, and are displayed in the same order
in which they appear in the original full heatmap - which means
\code{cluster_rows=FALSE} is defined at this point. However \code{row_split}
is retained for this subset of rows, to indicate the original
row split annotation.
\item Note that \code{row_subcluster} must match the \code{names()} returned
by \code{jamba::heatmap_row_order()} for the full heatmap, or should
include a \code{numeric} index for the \code{list} element or elements to
use.
\item In principle this process would be run in two stages: First,
view a heatmap with \code{row_split=6}, then re-run the same heatmap
with \code{row_subcluster=4} to see cluster number 4 from the full
heatmap.
}}

\item{row_title_rot}{\code{numeric} value indicating text rotation in degrees
to use for row titles.}

\item{sample_color_list}{named \code{list} of color vectors or color functions,
where names correspond to colnames in either \code{colData(se)} or
\code{rowData(se)}, and which are passed to corresponding left or top
annotation functions. When colors are not defined,
\code{ComplexHeatmap::Heatmap()} will define colors using its own internal
function.}

\item{legend_at, legend_labels}{\code{numeric} and \code{character}, respectively,
to define custom values for the heatmap color gradient legend.
\itemize{
\item When \code{legend_at} is supplied, it is used as provided.
\item When \code{legend_labels} is supplied, it is used only when its length
equals \code{length(legend_at)}, in which case it is used as provided.
\item When \code{centerby_colnames=FALSE} and the matrix data does not contain
negative values, \code{legend_at} uses integers from \code{0} to \code{color_max},
to avoid presenting a color legend with unnecessary negative values.
However, when \code{color_max <= 1} it uses \code{pretty(c(0, color_max))},
removing extraneous values, then ensuring the maximum value is
\code{color_max}. For example when \code{color_max=0.85},
the \code{legend_at} is likely to be \code{c(0, 0.2, 0.4, 0.6, 0.8, 0.85)}.
\item When \code{centerby_colnames} is not \code{FALSE}, and/or data contains
negative values, the \code{legend_at} is symmetric above and below zero.
When \code{color_max <= 1} the label is created using
\code{pretty(c(-color_max, color_max))}, as described above, so \code{color_max}
is used as the minimum and maximum value.
When \code{color_max > 1} the \code{legend_at} uses integer steps.
\item When \code{color_max <= 1} the \code{legend_labels} are presented as-is with
no transformation.
\item When \code{color_max > 1} the \code{legend_labels} are transformed with
\code{exp2signed(x)} which is the inverse of \code{log2(1 + x)}. This inverse
tranform displays normal space values, in the case of centered data,
the values represent normal space fold changes.
For example the \code{legend_at=c(-2, -1, 0, 1, 2)} would result in
\code{legend_labels=c("-4", "-2", "1", "2", "4")}.
\item When \code{correlation=TRUE} the \code{legend_labels} by default use \code{legend_at},
following rules for \code{color_max <= 1} above.
Otherwise, \code{legend_labels} values inverse transformed from \code{log2(1 + x)}
in order to display normal space fold change values,
\item To override any of this behavior, supply both \code{legend_at}
and corresponding \code{legend_labels}.
}}

\item{subset_legend_colors}{\code{logical} indicating whether to subset colors
shown in the color key defined by \code{sample_color_list}, which is useful
when the heatmap only represents a subset of categorical color values.
\itemize{
\item When \code{subset_legend_colors == TRUE}, the color key will only
include colors shown in the \code{top_annotation}.
\item When \code{subset_legend_colors == FALSE} all colors defined in
\code{sample_color_list} will be included for each relevant column.
}}

\item{row_cex, column_cex}{\code{numeric} values used to adjust the row and
column name font size, relative to the automatic adjustment that
is already done based upon the number of rows and columns being
displayed.}

\item{row_anno_fontsize}{\code{numeric} base font size for row
annotation labels. This value is only used when \code{left_annotation_name_gp}
is not supplied. Note these labels appears underneath row annotations,
alongside column labels, and therefore they are also adjusted
by multiplying \code{column_cex} so these labels are adjusted together.}

\item{useMedian}{\code{logical} passed to \code{jamma::centerGeneData()} during
data centering.}

\item{show_row_names, show_row_dend}{\code{logical} indicating whether to
display row names, and row dendrogram, respectively. With more than
2,000 rows this step can become somewhat slow.}

\item{mark_rows}{\code{character} vector of values in \code{rownames(se)} that
should be labeled using \code{ComplexHeatmap::anno_mark()} in call-out
style. Usually this argument is used when \code{show_row_names=FALSE},
hiding the row labels, but is not required. Values in \code{mark_rows}
are intersected with rows displayed in the heatmap, therefore only
matching entries will be labeled.}

\item{mark_labels_gp}{\code{grid::gpar} to customize the font used by labels
when \code{mark_rows} is supplied.}

\item{show_heatmap_legend, show_left_legend, show_top_legend}{\code{logical}
indicating whether each legend should be displayed. Sometimes there
are too many annotations, and the color legends can overwhelm the
figure. Note that \code{show_left_legend} is applied in a specific order,
with these rules:
\itemize{
\item \code{show_left_legend} is extended to at least length 2, then values
are used in order for: \code{sestats}, \code{rowData_colnames}, in order,
using whichever is defined.
\item If \code{sestats} is defined, the first value in \code{show_left_legend}
is used for this annotation, then the remaining values are used
for \code{rowData_colnames}. Setting the first \code{show_left_legend} value
to \code{FALSE} will ensure the legend for \code{sestats} is not displayed.
\item If \code{rowData_colnames} is defined, then the remaining values in
\code{show_left_legend} are recycled for all columns in
\code{rowData_colnames}, and applied in order.
In this way, individual columns can have the legend displayed or hidden.
\item If \code{alt_sestats} is defined, the legend is always hidden, in favor
of showing only the legend for \code{sestats} without duplicating this legend.
}}

\item{show_top_annotation_name, show_left_annotation_name}{\code{logical}
indicating whether to display the annotation name beside the top and
left annotations, respectively.}

\item{row_label_colname}{\code{character} string used as a row label, where
this value is a colname in \code{rowData(se)}. It is useful when rownames
are some identifier that is not user-friendly, and where another column
in the data may provide a more helpful label, for example \code{"SYMBOL"}
to display gene symbol instead of accession number.}

\item{cluster_columns, cluster_rows}{\code{logical} indicating whether
to cluster columns by hierarchical clustering; or \code{function} with
a specific function that produces \code{hclust} or \code{dendrogram} output,
given a \code{numeric} matrix. Note that \code{cluster_rows} default will replace
\code{NA} values with zero \code{0} to avoid errors with missing data, and
uses \code{amap::hcluster()} by default which is a one-step compiled
process to perform distance calculation and hierarchical clustering.}

\item{column_names_gp}{\code{gpar} to define custom column name settings.
When \code{"fontsize"} is not defined, the automatic font size calculation
is added to the \code{column_names_gp} supplied.}

\item{column_split}{\code{character} or \code{integer} vector used to define
heatmap column split.}

\item{column_split_sep}{\code{character} string used as delimited when
\code{column_split} defines multiple split levels.}

\item{color_max}{\code{numeric} value passed to \code{colorjam::col_div_xf()}
which defines the upper limit of color gradient used in the heatmap.}

\item{color_floor}{\code{numeric} value passed to \code{colorjam::col_div_xf()}
argument \code{floor} which defines the minimum non-zero numeric value
for a color to be applied. This option is available to prevent coloring
values below the \code{color_floor} which can be useful in some circumstances.}

\item{lens}{\code{numeric} value passed to \code{colorjam::col_div_xf()} to control
the intensity of color gradient applied to the numeric range.}

\item{rename_contrasts, rename_alt_contrasts}{\code{logical} indicating
whether to rename long contrast names in \code{sestats} and \code{alt_sestats}
using \code{contrast2comp()}.}

\item{use_raster}{\code{logical} passed to \code{ComplexHeatmap::Heatmap()} to
determine whether heatmaps should be converted to raster images,
which effectively turns each heatmap panel into a single graphical
object.
Recommend \code{use_raster=TRUE} and also installing R package \code{magick}
which greatly enhances speed and quality of rasterized heatmap
output. When \code{magick} is not available, it may be best to use
\code{use_raster=FALSE}.
When \code{use_raster=FALSE} each pixel square of a heatmap
is its own graphical object. For heatmaps with very large dimensions,
having each pixel as an object can make the heatmap extremely large
in memory, and sometimes pixels can overlap others because the
minimum pixel size of the output graphics device does not
reflect the actual size of each pixel.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{debug}{\code{logical} indicating debug mode, data is returned in a \code{list}:
\itemize{
\item \code{hm} object \code{ComplexHeatmap::Heatmap}
\item \code{top_annotation} object \code{ComplexHeatmap::HeatmapAnnotation} for columns
\item \code{left_annotation} object \code{ComplexHeatmap::HeatmapAnnotation} for rows
\item \code{hm_title} object \code{character} string with the heatmap title.
}}

\item{...}{additional arguments are passed to supporting functions.}
}
\description{
Expression heatmap of sestats hits
}
\details{
Note: Still a work in progress.

This function is a bold attempt to simplify the intricate task
of creating an expression heatmap, using \code{ComplexHeatmap::Heatmap()},
given a \code{SummarizedExperiment} object.

It attempts to enable:
\itemize{
\item selection of \code{assays(se)} to use in the heatmap
\item Use of \code{rowData(se)} or \code{colData(se)} to produce row and
column annotations, respectively.
\item Re-use of defined colors for annotations.
\item Use of color gradient and numeric default for typical heatmaps.
\item Convenient row data centering, versus all columns, or controls,
or centering of independent centering groups.
\item Convenient display of statistical hits beside the heatmap.
By default rows are subsetted to show only statistical hits.
\item Row and column split by \code{rowData(se)} and \code{colData(se)} annotations.
}

Additional features:
\itemize{
\item Data centering can be disabled with \code{centerby_colnames=FALSE}.
\item Alternative hits can be displayed using \code{alt_sestats}. It does not
subset heatmap rows, it inherits rows from \code{sestats}.
\item Display a subset of columns after centering, useful to hide
the control group for certain figures.
\item Option to display sample correlation heatmap, which re-uses the same data
centering, then calculates Pearson correlation across sample columns.
\item Various labels and legend grids can be customized to exact sizes
based upon \code{grid::gpar()} and \code{grid::unit()} definitions, useful
for publication figures.
\item Row mark annotations can be used to label only a subset of rows,
useful when the heatmap includes far too many labels to read them all.
\item Specific row split subclusters can be visualized using
\code{row_subcluster} to define the specific \code{row_split} entry, useful
for drilling into a specific subcluster from hierarchical clustering
without the manual effort to extract the subset of rows in that cluster
then re-running a new \code{heatmap_se()}.
}

The intent is to display expression values from \code{assays(se)},
centered across all columns, or with customization defined by
\code{centerby_colnames} and \code{normgroup_colnames}. The resulting centered
data can be subsetted by argument \code{isamples}, which occurs after
centering in order to decouple the centering step from the display
of resulting data. To subset samples involved in centering itself,
either subset the input \code{se} data, or supply \code{controlSamples} to
define a subset of samples used as the baseline in centering.
See \code{jamma::centerGeneData()} for more details.

Note: data centering can be disabled with \code{centerby_colnames=FALSE}.

The top heatmap annotations use \code{colData(se)} with user-supplied
\code{top_colnames} or by auto-detecting those colnames that apply
to multiple \code{colnames(se)}.

The \code{hit_array} data is used to define an incidence matrix of up/down
hits, which is displayed to the left of the heatmap. The contrasts
can optionally be subset with \code{contrast_names}.

The heatmap title is returned as an \code{attr(hm, "hm_title")} that
describes the assay data used, data centering, and total rows
displayed. Draw the resulting heatmap like this:

\verb{ComplexHeatmap::draw(hm, column_title=attr(hm, "hm_title))}

For comparison across other \code{sestats} results, argument \code{alt_sestats}
allows supplying an alternative hit array. These hit arrays are placed
as \code{left_annotation}, alongside optional data defined by \code{rowData_colnames}.

When \code{rowData_colnames} is supplied, data in the corresponding colnames
of \code{rowData(se)} are also displayed in \code{left_annotation}. Colors can
be defined in \code{sample_color_list}.

Argument \code{sample_color_list} is a \code{list} named by each annotation column
to be displayed as top or left annotation. Each list element is a vector
of R colors named by \code{character} value, or for \code{numeric} columns is a
color \code{function} as produced by \code{circlize::colorRamp2()}.
The function \code{platjam::design2colors()} is intended to create
\code{sample_color_list}, and will soon be moved into this package.

A custom \code{left_annotation} can be supplied, but this method currently
prevents the other annotations described above from being displayed.
Currently the best way to supply custom row annotations in addition
to those described above, supply \code{right_annotation} to be displayed
on the right side of the heatmap.

Data provided in \code{se} is expected to be \code{SummarizedExperiment}, however
it also accepts other Bioconductor data types that provide
accessor functions \code{featureData()}, \code{phenoData()}, and \code{assayData()},
including for example \code{"MethyLumiSet"} class.
}
\examples{
set.seed(123)
nr <- 1000;
nc <- 32;
m <- matrix(ncol=nc, nrow=nr, rnorm(nc * nr) * 0.8);
k <- seq_len(nr*2/4)+nr*2/4;
m[k, c(1:8+8, 1:8+16+8)] <- m[k, c(1:8+8, 1:8+16+8)] +
   rnorm(8 * nr*2/5)*1 + 2;
k <- seq_len(nr/4)+nr*3/4;
m[k, c(17:32)] <- m[k, c(17:32)] +
   rnorm(8 * nr/5)*1 - 3.5;
rownames(m) <- jamba::makeNames(rep("gene", nrow(m)));
colnames(m) <- jamba::makeNames(rep("sample", ncol(m)));
se <- SummarizedExperiment::SummarizedExperiment(
   assays=list(counts=m),
   rowData=data.frame(row.names=rownames(m),
      Class=rep(c("A", "A", "B", "C"), each=nr/4)),
   colData=data.frame(row.names=colnames(m),
      Group=rep(c("WildType", "Dex", "MG132", "DEX+MG132"), each=nc/4)))

# optionally define factor levels to force the order of labels
colData(se)$Group <- factor(colData(se)$Group,
   levels=unique(colData(se)$Group))

# basic heatmap
hm <- heatmap_se(se)

# draw by printing hm, or call draw() to add useful options
ComplexHeatmap::draw(hm,
   column_title=attr(hm, "hm_title"),
   merge_legends=TRUE)

# add specific colors
sample_color_list <- list(
   Group=colorjam::group2colors(unique(colData(se)$Group)),
   Class=colorjam::group2colors(unique(rowData(se)$Class)))

heatmap_se(se,
   sample_color_list=sample_color_list)

# let's have some fun now
heatmap_se(se,
   column_split=c("Group"),
   column_title_rot=90,
   row_split=c("Class"),
   rowData_colnames=c("Class"),
   cluster_row_slices=FALSE,
   sample_color_list=sample_color_list)

# center by WildType samples
# - controlSamples
# - control_label
hm2 <- heatmap_se(se,
   controlSamples=rownames(subset(colData(se), Group \%in\% "WildType")),
   control_label="vs WildType",
   column_split=c("Group"),
   column_title_rot=90,
   row_split=c("Class"),
   rowData_colnames=c("Class"),
   cluster_row_slices=FALSE,
   sample_color_list=sample_color_list)
hm2drawn <- ComplexHeatmap::draw(hm2,
   column_title=attr(hm2, "hm_title"),
   merge_legends=TRUE)

# labels only a subset of rows
mark_rows <- c(sample(jamba::heatmap_row_order(hm2drawn)[[1]], size=5),
   sample(jamba::heatmap_row_order(hm2drawn)[[1]], size=3));
hm3 <- heatmap_se(se,
   mark_rows=mark_rows,
   controlSamples=rownames(subset(colData(se), Group \%in\% "WildType")),
   control_label="vs WildType",
   column_split=c("Group"),
   column_title_rot=90,
   row_split=c("Class"),
   rowData_colnames=c("Class"),
   cluster_row_slices=FALSE,
   sample_color_list=sample_color_list)
ComplexHeatmap::draw(hm3,
   column_title=attr(hm3, "hm_title"),
   merge_legends=TRUE)

# sestats can accept list, incidence matrix, hit_array, or sestats
sestats_list <- list(
   contrast1=setNames(sample(c(1, -1), replace=TRUE, size=50),
      sample(rownames(se), size=50)),
   contrast2=setNames(sample(c(1, -1), replace=TRUE, size=50),
      sample(rownames(se), size=50)))
hm4 <- heatmap_se(se,
   controlSamples=rownames(subset(colData(se), Group \%in\% "WildType")),
   control_label="vs WildType",
   sestats=sestats_list,
   column_split=c("Group"),
   row_split=c("Class"),
   rowData_colnames=c("Class"),
   cluster_row_slices=FALSE,
   sample_color_list=sample_color_list)
ComplexHeatmap::draw(hm4,
   column_title=attr(hm4, "hm_title"),
   merge_legends=TRUE)

# sestats as incidence matrix
# - automatically subsets rows unless rows is defined
sestats_im <- venndir::list2im_value(sestats_list, do_sparse=FALSE)
hm5 <- heatmap_se(se,
   controlSamples=rownames(subset(colData(se), Group \%in\% "WildType")),
   control_label="vs WildType",
   sestats=sestats_im,
   column_split=c("Group"),
   row_split=c("Class"),
   rowData_colnames=c("Class"),
   cluster_row_slices=FALSE,
   sample_color_list=sample_color_list)
ComplexHeatmap::draw(hm5,
   column_title=attr(hm5, "hm_title"),
   merge_legends=TRUE)

# custom column_names_gp
hm6 <- heatmap_se(se,
   controlSamples=rownames(subset(colData(se), Group \%in\% "WildType")),
   control_label="vs WildType",
   column_names_gp=grid::gpar(col=sample_color_list$Group[as.character(colData(se)$Group)],
      font=rep(c(1, 2, 1), c(3, 5, 24))),
   column_split=c("Group"),
   row_split=c("Class"),
   rowData_colnames=c("Class"),
   cluster_row_slices=FALSE,
   sample_color_list=sample_color_list)
ComplexHeatmap::draw(hm6,
   column_title=attr(hm6, "hm_title"),
   merge_legends=TRUE)

# correlation heatmap
hm6corr <- heatmap_se(se,
   correlation=TRUE,
   controlSamples=rownames(subset(colData(se), Group \%in\% "WildType")),
   control_label="vs WildType",
   column_names_gp=grid::gpar(col=sample_color_list$Group[as.character(colData(se)$Group)],
      font=rep(c(1, 2, 1), c(3, 5, 24))),
   column_split=c("Group"),
   sample_color_list=sample_color_list)
ComplexHeatmap::draw(hm6corr,
   column_title=attr(hm6corr, "hm_title"),
   merge_legends=TRUE)

}
