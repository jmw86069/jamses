% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jam_senormalize.R
\name{matrix_normalize}
\alias{matrix_normalize}
\title{Normalize a numeric data matrix}
\usage{
matrix_normalize(
  x,
  method = c("quantile", "jammanorm", "limma_batch_adjust"),
  apply_log2 = c("ifneeded", "no", "always"),
  floor = 0,
  enforce_norm_floor = TRUE,
  params = list(quantile = list(ties = TRUE), jammanorm = list(controlGenes = NULL,
    minimum_mean = 0, controlSamples = NULL, centerGroups = NULL, useMedian = FALSE,
    noise_floor = NULL, noise_floor_value = NULL), limma_batch_adjust = list(batch =
    NULL, group = NULL)),
  verbose = TRUE,
  ...
)
}
\arguments{
\item{x}{\code{numeric} matrix with sample columns, and typically
gene rows, but any measured assay row will meet the assumptions
of the method.}

\item{method}{\code{character} string indicating which normalization
method to apply.}

\item{apply_log2}{\code{character} string indicating whether to apply
log2 transformation: \code{"ifneeded"} will apply log2 transform
when any absolute value is greater than 40; \code{"no"} will not
apply log2 transformation; \code{"always"} will apply log2 transform.
Note the log2 transform is applied with \code{jamba::log2signed(x, offset=1)}
which is equivalent to \code{log(1 + x)} except that negative values
are also transformed using the absolute value, then multiplied
by their original sign.}

\item{floor}{\code{numeric} value indicating the lowest accepted numeric
value, below which values are assigned to this floor. The default
\code{floor=0} requires all values are \code{0}, and any values below \code{0} are
assigned \code{0}. Note that the \code{floor} is applied after log2 transform,
when the log2 transform is performed.}

\item{enforce_norm_floor}{\code{logical} indicating whether to enforce the
\code{floor} for the normalized results, default is \code{TRUE}. For example,
when \code{floor=0} any values at or below \code{0} are set to \code{0} before
normalization. After normalization some of these values will be
above or below \code{0}. When \code{enforce_norm_floor=TRUE} these values
will again be set to \code{0} because they are considered to be
below the noise threshold of the protocol, and adjustments
are not relevant; also any normalized values below the \code{floor}
will also be set to \code{floor}.}

\item{params}{\code{list} of parameters relevant to the \code{method} of
normalization. The \code{params} should be a \code{list} named by the \code{method},
whose values are a list named by the relevant method parameter.
See examples.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}
}
\value{
\code{numeric} matrix with the same dimensions as the
input matrix \code{x}. Some normalization methods return
additional information in \code{attributes(x)}, for example
\code{method="jammanorm"} will return the vector of housekeeper
genes used in \code{attr(x, "hk")} for normalization of each sample
when supplied with \code{controlGenes} values.
}
\description{
Normalize a numeric data matrix
}
\details{
This function is a wrapper for several relevant normalization
methods that operate on a numeric matrix.
}
\section{Normalization Methods Implemented:}{
\subsection{method='quantile'}{

Quantile-normalization performed by
\code{limma::normalizeQuantiles()}. This method has one
parameter \code{"ties"} passed to \code{limma::normalizeQuantiles()},
the default here \code{ties=TRUE} which handles tied numeric
expression values in a robust way to avoid unpredictability
otherwise. This option is especially relevant with expression
count data, where integer counts cause a large number
of values to be represented multiple times.
}

\subsection{method='jammanorm'}{

Median-normalization performed by
\code{jamma::jammanorm()}. This method shifts expression
data as shown on MA-plots, so the median expression
is zero across all samples, using only the rows that
meet the relevant criteria.

Some relevant criteria to
define rows used for normalization:
\itemize{
\item \code{controlGenes} defines specific genes to use for
normalization, such as housekeeper genes. It may also
be useful to use detected genes here, so the normalization
only considers those genes defined as detected by
the protocol.
\item \code{minimum_mean} sets a numeric threshold and requires
the mean expression (shown on the x-axis of the MA-plot)
to be at least this value.
}

Note that when both \code{controlGenes} and \code{minimum_mean}
are defined, both criteria are enforced. So the \code{controlGenes}
are also required to have expression of at least \code{minimum_mean}.

Also note that all rows of data are normalized by this method,
only the subset of rows defined by \code{controlGenes} and \code{minimum_mean}
are used to compute the normalization factor.
}

\subsection{method='limma_batch_adjust'}{

Batch adjustment performed by
\code{limma::removeBatchEffect()} which is intended to apply
batch-adjustment as a form of normalization, but which
does not represent full normalization itself. There are
two relevant parameters: \code{"batch"} which is a vector of
batch values in order of \code{colnames(x)}, and \code{"group"}
which is a vector of sample groups in order of \code{colnames(x)}.
}
}

\section{Other useful parameters}{
Note the \code{floor} and \code{enforce_norm_floor} have recommended
default values \code{floor=0} and \code{enforce_norm_floor=TRUE}. These
defaults will set any assay value at or below \code{0} to \code{0},
and after normalization any values whose input values were
at or below \code{0} will also be set to \code{0} to prevent normalizing
a value of \code{0} to non-zero. Any normalized value at or
below \code{0} will also be set to \code{0} to prevent results from
containing negative normalized values.

The assumption for this default is that a value of zero
is not a measurement but represents the lack of a measurement.
Similarly, the intent of \code{floor} is a numeric threshold at or
below there is no confidence in the reported measurement, therefore
values at or below this threshold are treated as equivalent
to the threshold for the purpose of downstream analyses.

Some platforms like QPCR for example, have substantially lower
confidence at high CT values, where expression values
using the equation \code{2^(40-CT)} might impose a noise threshold
at expression 32 or lower. This noise threshold for QPCR
means any expression measurement of 32 or lower is as likely
to be \code{32} as it is to be \code{2}, and therefore any differences
between reported expression of \code{32} and \code{2} should not be
considered relevant. Applying \code{floor=32} in this case
accomplishes this goal by setting all values at or below
\code{32} to \code{32}. Of course when using this method \code{matrix_normalize()}
the data should be log2 transformed, which means the \code{floor}
should also be log2 transformed, e.g. \code{floor=log2(32)}
which is \code{floor=5}.

One alternative might be to set values at or below zero to \code{NA}
prior to normalization, and before calling \code{matrix_normalize()}.
In this case, only non-NA values will be used during
normalization according to the \code{method} being used.
}

\examples{
# use farrisdata real world data if available
if (jamba::check_pkg_installed("farrisdata")) {

   suppressPackageStartupMessages(library(SummarizedExperiment))

   # test matrix_normalize()
   GeneSE <- farrisdata::farrisGeneSE;
   imatrix <- assays(GeneSE)$raw_counts;
   genes <- rownames(imatrix);
   samples <- colnames(imatrix);
   head(imatrix);

   # matrix_normalize()
   # normalize the numeric matrix directly
   imatrix_norm <- matrix_normalize(imatrix,
      genes=genes,
      samples=samples,
      method="jammanorm",
      params=list(minimum_mean=5))
   names(attributes(imatrix_norm))

   # review normalization factors
   round(digits=3, attr(imatrix_norm, "nf"));

   # example for quantile normalization
   imatrix_quant <- matrix_normalize(imatrix,
      genes=genes,
      samples=samples,
      method="quantile")
   names(attributes(imatrix_quant))
}


# simulate reasonably common expression matrix
set.seed(123);
x <- matrix(rnorm(9000)/4, ncol=9);
colnames(x) <- paste0("sample", LETTERS[1:9]);
rownames(x) <- paste0("gene", jamba::padInteger(seq_len(nrow(x))))
rowmeans <- rbeta(nrow(x), shape1=2, shape2=5)*14+2;
x <- x + rowmeans;
for (i in 1:9) {
   x[,i] <- x[,i] + rnorm(1);
}

# display MA-plot with jamma::jammaplot()
jamma::jammaplot(x)

# normalize by jammanorm
xnorm <- matrix_normalize(x, method="jammanorm")
jamma::jammaplot(xnorm, maintitle="method='jammanorm'")

# normalize by jammanorm with housekeeper genes
hk_genes <- sample(rownames(x), 10);
xnormhk <- matrix_normalize(x,
   method="jammanorm",
   params=list(jammanorm=list(controlGenes=hk_genes)))

jamma::jammaplot(xnormhk,
   maintitle="method='jammanorm' with housekeeper genes",
   highlightPoints=list(housekeepers=hk_genes),
   highlightColor="green");

xnormhk6 <- matrix_normalize(x,
   method="jammanorm",
   params=list(jammanorm=list(
      controlGenes=hk_genes,
      minimum_mean=6)))
hk_used <- attr(xnormhk6, "hk")[[1]];
jamma::jammaplot(xnormhk6,
   maintitle="method='jammanorm' with housekeeper genes, minimum_mean=6",
   highlightPoints=list(housekeepers=hk_genes,
      hk_used=hk_used),
   highlightColor=c("red", "green"));

# normalize by quantile
xquant <- matrix_normalize(x, method="quantile")
jamma::jammaplot(xquant,
   maintitle="method='quantile'")

# simulate higher noise for lower signal
rownoise <- rnorm(prod(dim(x))) * (3 / ((rowmeans*1.5) - 1.5));
xnoise <- x;
xnoise <- xnoise + rownoise;
jamma::jammaplot(xnoise,
   maintitle="simulated higher noise at lower signal");

# simulate non-linearity across signal
# sin(seq(from=pi*4/10, to=pi*7/10, length.out=100))-0.8
rowadjust <- (sin(pi * jamba::normScale(rowmeans, from=3.5/10, to=5.5/10)) -0.9) * 20;
xwarp <- xnoise;
xwarp[,3] <- xnoise[,3] + rowadjust;
jamma::jammaplot(xwarp,
   maintitle="signal-dependent noise and non-linear effects");

# quantile-normalization is indicated for this scenario
xwarpnorm <- matrix_normalize(xwarp,
   method="quantile");
jp <- jamma::jammaplot(xwarpnorm,
   maintitle="quantile-normalized: signal-dependent noise and non-linear effects");

}
\seealso{
Other jamses stats: 
\code{\link{ebayes2dfs}()},
\code{\link{handle_na_values}()},
\code{\link{run_limma_replicate}()},
\code{\link{se_contrast_stats}()},
\code{\link{se_normalize}()},
\code{\link{voom_jam}()}
}
\concept{jamses stats}
