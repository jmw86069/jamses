% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jam_shrink_df.R
\name{shrinkDataFrame}
\alias{shrinkDataFrame}
\title{Shrink data.frame by row groups}
\usage{
shrinkDataFrame(
  x,
  groupBy,
  na.rm = TRUE,
  string_func = function(x) jamba::cPasteSU(x, na.rm = TRUE),
  num_func = function(x) {
     mean(x, na.rm = TRUE)
 },
  add_string_cols = NULL,
  num_to_string_func = as.character,
  keep_na_groups = TRUE,
  include_num_reps = FALSE,
  collapse_method = 2,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{x}{\code{data.frame} (or equivalent)}

\item{groupBy}{\code{character} vector with one of the following:
\itemize{
\item one or more columns in \code{colnames(x)}. The values in these columns
will define the row groups used.
\item \code{character} or \code{factor} with length equal to \code{nrow(x)}. These
values will define the row groups used.
}}

\item{string_func}{\code{function}, default uses \code{jamba::cPasteSU()},
used for \code{character} or \code{factor} columns. Note that string
columns are handled differently than \code{numeric} columns by applying
vectorized operations across the complete set of rows in one step,
rather than calling \code{data.table} on each subgroup.}

\item{num_func}{\code{function}, default \code{function(x)mean(x, na.rm=TRUE)},
used for \code{numeric} columns. Note that this function is applied
to each row group by \code{data.table}, and is typically very efficient
for \code{numeric} values.}

\item{add_string_cols}{\code{character} with optional \code{numeric} columns that
should be handled as if they were \code{character} columns. Default \code{NULL}.}

\item{num_to_string_func}{\code{function} used for \code{add_string_cols} when converting
\code{numeric} columns to \code{character}. Default \code{as.character()} retains
the full \code{numeric} value, however it may be useful to use something
like \code{function(x)signif(x, digits=3)} to limit the output to
only three significant digits, or \code{function(x)format(x, digits=3)}.}

\item{keep_na_groups}{\code{logical}, default TRUE, whether to convert \code{NA}
values in row groups to \code{""} so they are retained in the output.
\itemize{
\item You may want to use \code{keep_na_groups=FALSE} when there are a large
number of un-annotated rows that should not be aggregated together.
This situation may occur if converting a probe to a gene symbol,
where a subset of probes cannot be converted to a gene symbol
and instead receive \code{NA}.
}}

\item{include_num_reps}{\code{logical} indicating whether to add a column
\code{"num_reps"} to the output, with the \code{integer} number of rows
in each row group.}

\item{collapse_method}{\code{integer} default 2, indicating the internal
collapse method used. Experimental.
\itemize{
\item \code{1} collapses each \code{numeric} column independently.
\item \code{2} collapses each set of \code{numeric} columns that use the same
numeric shrink function. When all \code{numeric} columns use the same
shrink function, they are all calculated in a single step, which
is typically much faster.
}}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{...}{additional arguments are ignored.}
}
\description{
Shrink data.frame by row groups
}
\details{
Purpose is to shrink a \code{data.frame} to have one row per row grouping.
The row grouping can use a single column of identifiers, or multiple
columns. The challenge is to apply a relevant function to each column,
expecting there will be columns with \code{numeric}, \code{character}, or \code{factor}
types.

The default behavior:
\itemize{
\item \code{numeric} columns are summarized with \code{mean(x, na.rm=TRUE)}, so that
NA values are ignored when there are non-NA values present.
\item \code{character} columns are combined using unique, sorted \code{character} strings.
\itemize{
\item This step uses \code{jamba::cPasteSU()} where the
\code{S} activates sorting using \code{jamba::mixedSort()}, and
\code{U} calls \code{unique()}.
\item To retain all values, remove the \code{U} and call \code{jamba::cPasteS()}
\item To skip the sort, remove the \code{S} and call \code{jamba::cPasteU()}
\item To keep all values, and skip sorting, call \code{jamba::cPaste()}
}
}
}
\examples{
testdf <- data.frame(check.names=FALSE,
   SYMBOL=rep(c("ACTB", "GAPDH", "PPIA"), c(2, 3, 1)),
   `logFC B-A`=c(1.4, 1.4, 2.3, NA, 2.5, 5.1),
   probe=paste0("probe", 1:6))
shrink_df(testdf, by="SYMBOL")

shrink_df(testdf, by="SYMBOL", num_func=mean)

shrink_df(testdf, by="SYMBOL", add_string_cols="logFC B-A")

testdftall <- do.call(rbind, lapply(1:10000, function(i){
   idf <- testdf;
   idf$SYMBOL <- paste0(idf$SYMBOL, "_", i);
   idf;
}))
shrunk_tall <- shrink_df(testdftall,
   by="SYMBOL")
head(shrunk_tall, 6)

shrunk_tall2 <- jamses::shrinkDataFrame(testdftall,
   groupBy="SYMBOL")
head(shrunk_tall2, 6)

}
\seealso{
Other jamses utilities: 
\code{\link{choose_annotation_colnames}()},
\code{\link{combine_sestats}()},
\code{\link{contrast2comp_dev}()},
\code{\link{fold_to_log2fold}()},
\code{\link{intercalate}()},
\code{\link{list2im_opt}()},
\code{\link{list_to_sestats}()},
\code{\link{log2fold_to_fold}()},
\code{\link{make_block_arrow_polygon}()},
\code{\link{mark_stat_hits}()},
\code{\link{matrix_normalize}()},
\code{\link{merge_statdf_all_test}()},
\code{\link{point_handedness}()},
\code{\link{point_slope_intercept}()},
\code{\link{shortest_unique_abbreviation}()},
\code{\link{shrink_df}()},
\code{\link{shrink_matrix}()},
\code{\link{sort_samples}()},
\code{\link{strsplitOrdered}()},
\code{\link{sub_split_vector}()},
\code{\link{update_function_params}()},
\code{\link{update_list_elements}()}
}
\concept{jamses utilities}
